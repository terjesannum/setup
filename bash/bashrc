# -*- mode: shell-script; -*-
# Generic bashrc, this will be sourced on all host. Use bashrc.emacshost for setup not needed on remote hosts, pods etc.

test -r /etc/bashrc && . /etc/bashrc
test -r $HOME/lib/bash/local.sh && . $HOME/lib/bash/local.sh

add_path() {
    dir=$1
    if [[ :$PATH: =~ :$dir: ]]; then
        PATH="${PATH#$dir:}"        # remove if at start
        PATH="${PATH%:$dir}"        # remove if at end
        PATH="${PATH//:$dir:/:}"    # remove if in middle
    fi
    PATH="$dir:$PATH"               # add to start
}

for dir in \
    $HOME/bin \
    /usr/local/opt/gnu-sed/libexec/gnubin \
    /usr/local/opt/coreutils/libexec/gnubin \
    /usr/local/opt/python/libexec/bin \
    /usr/local/go/bin \
    ; do
    test -d $dir && add_path $dir
done

if test $UID -eq 0; then
    prompt_color=31
elif test -n "$GDMSESSION" -o `uname -s` = 'Darwin' || uname -a | grep -q Microsoft; then
    prompt_color=32
    local_shell=1
else
    prompt_color=36
fi

__prompt_exit_code() {
    local r=$?
    if test "$r" = "0"; then
        echo -e "\\e[0;32m[0]\\e[m"
    else
        echo -e "\\e[0;31m[$r]\\e[m"
    fi
}

base_prompt="\\e[0;33m[\\t]\\e[m\$(__prompt_exit_code) \\e[0;${prompt_color}m\\u@\\h\\e[m \\e[0;33m\\w\\e[m"
PS1="${base_prompt}\\n\\\$ "
PS2="> "

for git_prompt in \
    /Applications/Xcode.app/Contents/Developer/usr/share/git-core/git-prompt.sh \
    /Library/Developer/CommandLineTools/usr/share/git-core/git-prompt.sh \
    /usr/share/git-core/contrib/completion/git-prompt.sh \
    /usr/lib/git-core/git-sh-prompt \
    ; do
    if test -r $git_prompt; then
        GIT_PROMPT=$git_prompt
        break
    fi
done

if test -n "$GIT_PROMPT"; then
  . $GIT_PROMPT
  GIT_PS1_SHOWDIRTYSTATE=1
  GIT_PS1_SHOWSTASHSTATE=1
  GIT_PS1_SHOWUNTRACKEDFILES=1
  GIT_PS1_SHOWUPSTREAM=auto
  PS1="${base_prompt}\$(__git_ps1 \" \\e[${prompt_color}m(%s)\")\\e[m\\n\\\$ "
fi

export LC_CTYPE=en_US.UTF-8
export LC_ALL=en_US.UTF-8

export CLICOLOR=1
export COLORTERM=1
export LSCOLORS=ExFxBxDxCxegedabagacad
if echo foo | grep --color=auto foo >/dev/null 2>&1; then
    alias grep='grep --color=auto'
fi
alias ls='ls --color=auto'

alias cd..='cd ..'

if type shasum &>/dev/null; then
    type sha1sum &>/dev/null || alias sha1sum='shasum -a 1'
    type sha256sum &>/dev/null || alias sha256sum='shasum -a 256'
fi

for dir in \
    /usr/lib/oracle/12.2/client64/lib \
    ; do
    test -d $dir && export LD_LIBRARY_PATH=$dir:$LD_LIBRARY_PATH
done

if test ! -z $INFLUX_HOST; then
    alias influx='influx -host $INFLUX_HOST -database $INFLUX_DATABASE -precision rfc3339'
fi

if type brew &>/dev/null && test -r $(brew --prefix)/share/bash-completion/bash_completion; then
  . $(brew --prefix)/share/bash-completion/bash_completion
fi

if type minikube &>/dev/null; then
   alias minikube-docker-env='eval $(minikube docker-env)'
fi

if type kubectl &>/dev/null; then
  . <(kubectl completion bash)
  alias k=kubectl
  alias kd='kubectl --namespace default'
  alias ks='kubectl --namespace kube-system'
  alias kn='kubectl --namespace nais'
  alias ki='kubectl --namespace istio-system'
  alias kt='kubectl --namespace tpa'
  K_GET_ALL_EXCLUDE='(?:^events|\.events\.k8s\.io|\.velero\.io|\.rook\.io)$'
  k-get-all() {
    if test "$1" = "-a" -o -z "$K_GET_ALL_EXCLUDE"; then
      all=1
    else
      all=0
    fi
    kubectl api-resources --verbs=list --namespaced -o name | (if test $all -gt 0; then cat; else grep -v -E $K_GET_ALL_EXCLUDE; fi) | xargs -n 1 kubectl get --show-kind --ignore-not-found
  }
fi

if type kubectx &>/dev/null; then
  . $HOME/lib/bash/github.com/kubectx/completion/kubectx.bash
  alias kc=kubectx
fi

if type kubens &>/dev/null; then
  . $HOME/lib/bash/github.com/kubectx/completion/kubens.bash
  alias kns=kubens
fi

if type helm &>/dev/null; then
  . <(helm completion bash)
fi

if test -r $GOOGLE_CLOUD_SDK_DIR/path.bash.inc; then
    . $GOOGLE_CLOUD_SDK_DIR/path.bash.inc
    if type _completion_loader &>/dev/null && test -r $GOOGLE_CLOUD_SDK_DIR/completion.bash.inc; then
        . $GOOGLE_CLOUD_SDK_DIR/completion.bash.inc
    fi
fi

if type _completion_loader &>/dev/null && test -r $HOME/lib/bash/github.com/complete-alias/complete_alias; then
   . $HOME/lib/bash/github.com/complete-alias/complete_alias
   if type kubectl &>/dev/null; then
      complete -F _complete_alias k
      complete -F _complete_alias kd
      complete -F _complete_alias ks
      complete -F _complete_alias kn
      complete -F _complete_alias ki
      complete -F _complete_alias kt
   fi
   if type kubectx &>/dev/null; then
      complete -F _complete_alias kc
   fi
   if type kubens &>/dev/null; then
      complete -F _complete_alias kns
   fi
fi

if test -d $HOME/perl5/lib/perl5; then
    eval "$(perl -I$HOME/perl5/lib/perl5 -Mlocal::lib)"
fi

if test -n "$INSIDE_EMACS"; then
    export PAGER=cat
    unset HISTFILE
    if test -n "$local_shell" && type emacsclient &>/dev/null ; then
        export EDITOR=emacsclient
        if test -f $HOME/lib/bash/github.com/ealias/ealias; then
            . $HOME/lib/bash/github.com/ealias/ealias
            ealias essh='ssh-shell %*'
            ealias sussh='sudo-shell %*'
            ealias ff='find-file %* t'
        fi
        if type kubectl &>/dev/null; then
            export PROMPT_COMMAND="emacsclient -e '(kubectx-mode-mode-line-update)' &>/dev/null"
        fi
    fi
fi

if type docker &>/dev/null; then
    alias docker-rm-all='docker rm -f $(docker ps -a -q)'
    alias docker-irm-all='docker rmi $(docker images -a -q)'
    alias docker-ip="docker inspect --format '{{ .NetworkSettings.IPAddress }}'"
fi

epoch() {
    date -d @$(echo $1 | cut -c-10)
}

if type vault &>/dev/null && test -r /etc/vault/tls/ca.pem; then
    export VAULT_ADDR=https://$(hostname -f):8200
    export VAULT_CAPATH=/etc/vault/tls/ca.pem
fi

if test -d /proc; then
    alias pswap="find /proc -maxdepth 2 -path \"/proc/[0-9]*/status\" -readable -exec awk -v FS=\":\" '{process[\$1]=\$2;sub(/^[ \t]+/,\"\",process[\$1]);} END {if(process[\"VmSwap\"] && process[\"VmSwap\"] != \"0 kB\") printf \"%10s %-30s %20s\n\",process[\"Pid\"],process[\"Name\"],process[\"VmSwap\"]}' '{}' \; | awk '{print \$(NF-1),\$0}' | sort -h | cut -d \" \" -f2-"
fi

if type openssl &>/dev/null; then
    _parse_url_args() {
        h=`echo $1 | sed -r 's,^https://([^/]*).*,\1,'`
        if echo $h | grep -q :; then
            p=`echo $h | cut -f2 -d:`
            h=`echo $h | cut -f1 -d:`
        elif test $# -eq 1; then
            p=443
        else
            p=$2
        fi
    }
    showcert() {
        if test -r "$1"; then
            openssl x509 -in $1 -text -noout
        else
            _parse_url_args $1 $2
            if test "$p" -eq "$p" 2>/dev/null; then
                echo | openssl s_client -servername $h -connect $h:$p 2>/dev/null | openssl x509 -text -noout
            else
                echo "Usage: showcert <file|host|url> [port]" 1>&2
                false
            fi
        fi
    }
    getcert() {
        _parse_url_args $1 $2
        if test "$p" -eq "$p" 2>/dev/null; then
            echo | openssl s_client -servername $h -connect $h:$p | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p'
        else
            echo "Usage: getcert <host|url> [port]" 1>&2
            false
        fi
    }
fi

# For use in emacs-shell, trigger send-invisible to read a secret on stdin and assign value to a variable
read_secret() {
    arg=$1
    if test "$arg" = "-E"; then
        exp=1
        arg=$2
    else
        exp=0
    fi
    if test -z "$arg"; then
        echo "Usage: read_secret [-E] <variable>"
        return 1
    else
        read -p 'Password: ' $arg
        test $exp -eq 1 && export $arg
        return 0
    fi
}
